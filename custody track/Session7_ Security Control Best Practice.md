# 수탁형 지갑 보안 설계

사례 기반 패턴 학습

------------------------------------------------------------------------

## 슬라이드 1

수탁형 지갑 보안 설계 사례 기반 패턴 학습

2026년 2월 14일

보안은 키를 숨기는 것이 아니라 잘못된 송금을 구조적으로 막는 것이다

\[1\]

------------------------------------------------------------------------

## 슬라이드 2

목차

• 세션 목표 • 패턴 1: 주소 화이트리스트 + 보류 • 패턴 2: 정책 엔진
무결성 • 패턴 3: Signer 경계에서 정책 검증 • 패턴 4: 키 구조 기반 분리
적합 • 통합 설계 및 결론

\[2\]

------------------------------------------------------------------------

## 슬라이드 3

세션 목표

· 수탁형 지갑의 목적을 이해하고 · 보안 통제를 시스템 설계에 녹이는
방법을 학습하며 · 4개의 패턴과 사례를 통해 실무 설계 규칙을 도출

\[3\]

------------------------------------------------------------------------

## 슬라이드 4

구조적 보안 vs 단순 키 숨김

수탁형 지갑은 단순히 비밀키를 감추는 것에 그치지 않습니다.

· 설계 목표는 잘못된 송금이 구조적으로 불가능하도록 만드는 것입니다. ·
정책과 절차가 키 관리 이상으로 중요한 방어선입니다. · 이 세션에서는
실수·침해·내부자 위험을 막는 구조적 패턴을 배웁니다.

\[4\] \[5\]

------------------------------------------------------------------------

## 슬라이드 5

통제 모듈 개요

보안 통제는 다양한 모듈이 협력하는 아키텍처에서 실행됩니다. 주요 모듈을
이해하면 패턴의 배치 위치를 쉽게 파악할 수 있습니다.

사용자 인터페이스

API/오케스트레이터

정책 엔진

승인(Approval)

Signer/HSM

원장·감사(Ledger/Audit)

모니터링/알림

\[6\] \[7\]

------------------------------------------------------------------------

## 슬라이드 6

패턴 1 주소 화이트리스트 + 보류

실수와 침해를 구조적으로 늦춘다

\[8\]

------------------------------------------------------------------------

## 슬라이드 7

패턴 1 개념

· 주소를 미리 등록하고 승인받은 주소만 출금 가능하도록 제한합니다. ·
새로 등록한 주소는 일정 기간 동안 보류(Hold) 상태로 두어 즉시 사용하지
못합니다. · 보류 기간 동안 알림을 통해 사용자와 관리자에게 변경 사실을
알려 대응 시간을 확보합니다.

\[9\]

------------------------------------------------------------------------

## 슬라이드 8

Coinbase 사례

· Coinbase는 주소록 기능을 통해 허용된 주소만 송금할 수 있도록 합니다. ·
새 주소를 추가하면 48시간 보류 기간이 적용되며, 보류 중에는 출금이
차단됩니다. · 이용자가 허용리스트를 변경하거나 비활성화할 때도 48시간
지연이 적용됩니다.

\[10\] \[11\] \[12\]

------------------------------------------------------------------------

## 슬라이드 9

추가 사례 및 경험

· Aura 보안 블로그는 주소록 변경 시 48시간 지연을 강조하고, Vault
계정에도 동일한 지연이 존재한다고 소개했습니다. · Reddit 사용자들도
허용리스트를 끌 경우 48시간 동안 거래가 지연된다는 경험을 공유했습니다.

\[13\] \[14\]

------------------------------------------------------------------------

## 슬라이드 10

왜 보류가 필요한가?

· 인간의 복사/붙여넣기 실수나 악성 소프트웨어의 주소 변조를 완화합니다.
· 계정이 침해되더라도 즉시 송금할 수 없게 만들어 대응 시간을 벌어
줍니다. · 주소 등록·활성화 과정에서 승인과 감사 로그를 남겨 규제 준수를
강화합니다.

\[15\]

------------------------------------------------------------------------

## 슬라이드 11

주소 등록 상태 머신

등록→승인→지연→활성화 순서로 주소가 상태를 이동합니다. 각 단계에서
로그를 남기고 관리자 알림을 발송합니다.

등록

승인

지연

활성화

\[16\]

------------------------------------------------------------------------

## 슬라이드 12

패턴 1: 설계 규칙

1.  화이트리스트는 지연을 포함한 상태 머신으로 구현합니다.
2.  보류 기간 기본값은 48시간이며, 고객 유형에 따라 조정 가능하게
    설계합니다.
3.  정책 엔진, 승인, 감사 모듈을 분리하여 모든 상태 변화를 기록합니다.
4.  사용자와 관리자에게 명확한 알림과 UI 안내를 제공합니다.

\[17\]

------------------------------------------------------------------------

## 슬라이드 13

예상 보류 기간 비교

\[18\]

------------------------------------------------------------------------

## 슬라이드 14

보류의 영향과 균형

· 보안 강화: 보류가 침해를 늦추어 대응 시간을 제공합니다. · 사용자 경험:
즉시 출금이 불가하므로 고객 만족도가 떨어질 수 있습니다. · 맞춤형 정책:
기업 고객, VIP 고객 등 상황에 따라 보류 시간을 유연하게 조정합니다. ·
규제 준수: 주소 보류 중에도 자금세탁방지(AML) 검사를 동시에 진행할 수
있습니다.

\[19\]

------------------------------------------------------------------------

## 슬라이드 15

패턴 1 요약

· 주소 등록과 지연을 통한 인간·자동화 실수 완화 · 48시간 보류로 계정
침해 대응 시간 확보 · 정책/승인/감사 모듈의 연계가 필수 · UX와 보안의
균형을 고려한 맞춤형 적용

\[20\]

------------------------------------------------------------------------

## 슬라이드 16

패턴 2 정책 엔진 무결성

정책을 바꾸는 것이 곧 사고다

\[21\]

------------------------------------------------------------------------

## 슬라이드 17

패턴 2 개념

· 정책(rule) 자체가 자산 보호의 마지막 방어선입니다. · 정책 엔진은
코드가 아닌 버전 관리되는 규칙 세트로 다루어야 합니다. · 정책 변경
이벤트 자체를 고위험 사건으로 간주하고 별도 승인·지연·롤백 절차를
둡니다.

\[22\] \[23\]

------------------------------------------------------------------------

## 슬라이드 18

Fireblocks 사례

· Fireblocks는 민감한 연산을 SGX와 Nitro Enclave와 같은 신뢰 실행
환경에서 수행합니다. · 정책 엔진은 이런 TEE 안에서 실행되어 해커나
내부자가 규칙을 수정하지 못하도록 보호됩니다. · 정책 변경은 관리자가
quorum 승인을 거친 후에만 적용될 수 있습니다.

\[24\] \[25\]

------------------------------------------------------------------------

## 슬라이드 19

Fireblocks 상세 구조

· SGX/Nitro Enclave는 코드와 데이터를 암호화된 메모리에 넣어 운영체제나
관리자 권한에서도 볼 수 없습니다. · 정책 엔진과 키 쉐어가 동일한
enclave에 배치되어 둘 다 변조되지 않습니다. · 정책 변경은 메이커‑체커
구조로 다수의 관리자 서명이 필요합니다. · 모든 변경 이벤트는 원장과 감사
로그에 기록되며, 버전 간 diff를 확인할 수 있습니다.

\[26\] \[27\] \[28\]

------------------------------------------------------------------------

## 슬라이드 20

정책을 바꾸는 것은 왜 위험한가?

· 정책은 금액 한도, 주소 제한, 승인자 수 등 자산 이동의 마지막
방어선입니다. · 공격자는 정책을 낮추거나 해제해 출금 한도를 늘리려
합니다. · 정책 변경을 고위험 이벤트로 분류하고, 변경 제안 → 승인 → 지연
→ 적용의 절차를 통해 사고를 방지합니다.

\[29\]

------------------------------------------------------------------------

## 슬라이드 21

정책 변경 절차

정책 변경 이벤트는 별도의 승인 절차와 지연 시간을 둡니다.

변경 제안

관리자 승인

지연/롤백

적용

\[30\]

------------------------------------------------------------------------

## 슬라이드 22

패턴 2: 설계 규칙

1.  정책은 버전 관리되는 규칙 세트이며, 코드 if문으로 처리하지 않습니다.
2.  정책 변경은 트랜잭션 승인과 분리된 별도의 승인 프로세스를 둡니다.
3.  TEE 또는 HSM을 이용하여 정책 엔진을 신뢰 경계로 승격합니다.
4.  모든 정책 변경 이벤트를 Ledger/Audit에 기록하고 감시합니다.

\[31\] \[32\]

------------------------------------------------------------------------

## 슬라이드 23

정책 엔진 기능 요약

\[33\] \[34\]

------------------------------------------------------------------------

## 슬라이드 24

패턴 2 요약

· 정책을 시스템 코드가 아닌 규칙 세트로 관리 · 정책 변경 = 고위험 이벤트
(승인·지연·롤백 필요) · SGX/Nitro/HSM 등 TEE 활용으로 엔진 무결성을 확보
· 변경 이벤트를 감시·감사·경보하여 사고를 예방

\[35\] \[36\]

------------------------------------------------------------------------

## 슬라이드 25

패턴 3 Signer 경계에서의 정책 검증

최종 경계에서 다시 한번 검증한다

\[37\]

------------------------------------------------------------------------

## 슬라이드 26

패턴 3 개념

· 서명 장치(HSM/MPC) 내부에서 정책을 다시 검증합니다. · 오케스트레이터나
API가 허용한 거래라도, 서명 직전에 정책을 체크해 거부할 수 있습니다. ·
키와 정책을 동일한 신뢰 경계 안에 보관하여 단일 실패 지점을 제거합니다.

\[38\] \[39\]

------------------------------------------------------------------------

## 슬라이드 27

Anchorage 사례

· Anchorage는 에어갭된 HSM 안에 키를 저장하고, HSM 펌웨어에 정책 엔진을
내장합니다. · 트랜잭션 생성과 서명이 같은 장치에서 수행되며, 서명 시에
정책을 다시 확인합니다. · HSM은 서명해야 하는지 여부뿐 아니라 무엇을
서명하는지 검증합니다.

\[40\] \[41\] \[42\]

------------------------------------------------------------------------

## 슬라이드 28

Anchorage 구조 상세

· 트랜잭션 지시가 HSM으로 전달되면, HSM은 내부 정책 엔진으로부터 검증을
수행합니다. · HSM은 정책과 키를 모두 보호하므로, API가 해킹되어도 서명은
거부될 수 있습니다. · HSM 내부의 로그를 통해 각 서명 요청이 정책을
만족했는지 추적할 수 있습니다.

\[43\] \[44\] \[45\]

------------------------------------------------------------------------

## 슬라이드 29

왜 Signer 경계에서 검증하나?

· API나 오케스트레이터는 중간 계층일 뿐이며 해킹될 수 있습니다. · 서명은
자산 이동의 마지막 단계이므로, 여기서 정책을 다시 검증하면 잘못된 지시를
차단할 수 있습니다. · 최종 경계에서 서명과 검증을 통합하면 단일 실패점을
제거할 수 있습니다.

\[46\] \[47\]

------------------------------------------------------------------------

## 슬라이드 30

Signer 내 정책 검증

API→HSM→블록체인 흐름에서 HSM 내부의 정책 엔진이 마지막으로 검증합니다.

API/오케스트레이터

HSM

정책 엔진

블록체인

\[48\] \[49\]

------------------------------------------------------------------------

## 슬라이드 31

패턴 3: 설계 규칙

1.  서명 직전 HSM/MPC에서 정책을 재검증합니다.
2.  키와 정책을 동일한 보안 경계(HSM/SGX) 안에서 관리합니다.
3.  오케스트레이터는 알림/전달만 수행하고 최종 서명 권한을 갖지 않도록
    합니다.
4.  서명 모듈의 로그와 감사 기록을 중앙에서 모니터링합니다.

\[50\] \[51\]

------------------------------------------------------------------------

## 슬라이드 32

패턴 3 요약

· API 허가 후에도 HSM이 다시 검증한다 · 키와 정책을 동일한 HSM 경계에
보관 · 단일 실패 지점을 제거하고 로그로 추적 · 최종 Signer 경계가 마지막
방어선이다

\[52\] \[53\]

------------------------------------------------------------------------

## 슬라이드 33

패턴 4 키 구조 기반 분리 적합

한 사람이 모든 키를 갖지 못하게 하라

\[54\]

------------------------------------------------------------------------

## 슬라이드 34

패턴 4 개념

· 키 구조를 통해 승인자·요청자·서명자를 분리합니다. · 2-of-3, 3-of-5 등
서명 임계값을 정하여 단독 출금이 불가능하도록 합니다. · 키를 다른
소유주와 위치에 분산하고, 백업 키는 오프사이트에 보관합니다.

\[55\] \[56\]

------------------------------------------------------------------------

## 슬라이드 35

BitGo 사례

· BitGo는 온체인 지갑마다 사용자 키·백업 키·BitGo 키 세 개를 사용합니다.
· 2-of-3 구조에서 세 소유자 중 두 명이 서명해야만 자금이 이동합니다. ·
누구도 하나 이상의 키를 보유하지 못하도록 키를 분산합니다.

\[57\] \[58\]

------------------------------------------------------------------------

## 슬라이드 36

BitGo 구조 상세

· 모든 키는 서로 다른 소유주에게 분산되어 한 사람이 두 개 이상의 키를
보유하지 않습니다. · 백업 키는 오프사이트 혹은 제3자 수탁 기관에
보관하여 키 손실에 대비합니다. · 다중 서명 또는 MPC 방식 모두 2-of-3
구조를 기본으로 삼습니다.

\[59\] \[60\] \[61\]

------------------------------------------------------------------------

## 슬라이드 37

왜 키 구조가 중요한가?

· 내부자 위험 감소: 어떤 사람도 단독으로 자금을 이동할 수 없습니다. · 키
분실 대비: 2-of-3 구조는 하나의 키를 잃어도 나머지 두 키로 복구할 수
있습니다. · 역할 분리: 정책 엔진과 Signer 모듈을 분리하여 내부자 위험을
줄입니다.

\[62\] \[63\]

------------------------------------------------------------------------

## 슬라이드 38

2-of-3 멀티시그 다이어그램

세 명의 키 보유자가 있으며, 그 중 두 명의 서명이 있어야 거래가
수행됩니다.

키1

키2

키3

거래

2-of-3

\[64\] \[65\]

------------------------------------------------------------------------

## 슬라이드 39

패턴 4: 설계 규칙

1.  승인자·요청자·서명자를 키와 역할에 따라 분리합니다.
2.  기본 2-of-3 구조를 적용하고, 자산 규모에 따라 3-of-5 이상으로
    확장합니다.
3.  키는 물리적으로 분리하여 서로 다른 관리자나 장소에서 보관합니다.
4.  정책 엔진과 Signer 모듈을 분리하여 내부자 사고를 방지합니다.

\[66\] \[67\]

------------------------------------------------------------------------

## 슬라이드 40

패턴 4 요약

· 키 구조로 분리 적합을 강제하고 내부자 위험을 줄입니다 · 2-of-3
멀티시그가 기본이며 확장이 가능합니다 · 키 분실 시 복구 가능성을 높이고
역할 분리를 보장합니다 · 정책 모듈과 Signer 모듈을 독립적으로 유지합니다

\[68\] \[69\]

------------------------------------------------------------------------

## 슬라이드 41

패턴 비교

\[70\] \[71\] \[72\] \[73\]

------------------------------------------------------------------------

## 슬라이드 42

위험 범주별 패턴 효과

패턴들이 각 위험에 얼마나 대응하는지 1 = 낮음, 5 = 높음 척도로
표현했습니다.

\[74\] \[75\] \[76\] \[77\]

------------------------------------------------------------------------

## 슬라이드 43

통합 설계 권장 사항

· 각 패턴을 조합하여 다중 방어선을 구축합니다. · 주소 화이트리스트 +
정책 엔진 무결성 + Signer 검증 + 다중 키 구조를 동시에 적용합니다. ·
정책 엔진과 서명 모듈은 하드웨어 격리된 환경에서 실행하여 내부자와 외부
공격자 모두로부터 보호합니다. · 모든 이벤트는 감사 원장에 기록되어야
하며, 실시간 모니터링과 경보 체계를 구축합니다.

\[78\] \[79\] \[80\] \[81\]

------------------------------------------------------------------------

## 슬라이드 44

패턴과 모듈 배치

패턴을 어느 모듈에 적용할지 한눈에 보여줍니다.

UI

API

정책 엔진

승인

Signer

Ledger

모니터링

P1

P1

P1

P2

P2

P2

P3

P3

P4

P4

P1

P2

P3

P4

\[82\] \[83\] \[84\] \[85\]

------------------------------------------------------------------------

## 슬라이드 45

우리 설계 권장 사항

· 패턴 1--4를 조합하여 종합적인 통제를 구축합니다. · 개발자는 정책 변경
코드와 로그를 철저히 버전 관리하고, 변경 시 Quorum 서명을 요구합니다. ·
인프라 팀은 HSM/SGX와 같은 TEE를 도입해 키와 정책 엔진을 보호합니다. ·
조직은 역할·키·서명자를 엄격히 분리하고, 비상 상황에 대비한 백업·회전
절차를 문서화합니다.

\[86\] \[87\] \[88\] \[89\]

------------------------------------------------------------------------

## 슬라이드 46

사례 시나리오: 주소 입력 실수

· 사용자가 거래를 보내려다 악성 소프트웨어가 주소를 다른 값으로
바꿔치기합니다. · 새 주소는 허용리스트에 없으므로 등록·승인·지연 절차가
자동으로 발동합니다. · 48시간 지연 동안 사용자는 알림을 받고 잘못된
주소를 취소할 수 있습니다.

\[90\]

------------------------------------------------------------------------

## 슬라이드 47

사례 시나리오: 정책 변조 공격

· 공격자가 백엔드 서버를 해킹해 출금 한도를 무제한으로 바꾸려 합니다. ·
정책 엔진은 SGX enclave 안에서 실행되므로 외부 해킹으로는 변경할 수
없습니다. · 변경 요청은 메이커‑체커 승인과 지연을 거쳐야 하며,
Ledger/Audit에 기록됩니다.

\[91\] \[92\]

------------------------------------------------------------------------

## 슬라이드 48

결론 및 핵심 요점

· 보안은 키를 숨기는 기술이 아니라 구조적인 통제 설계입니다. · 4개
패턴은 서로 보완적이며, 함께 적용될 때 가장 강력합니다. · 주소 보류로
실수·침해를 늦추고, 정책 엔진을 하드웨어로 보호하며, 서명 단계에서 다시
검증하고, 키 구조로 내부자 위험을 줄입니다. · 설계자는 규제 준수, 사용자
경험, 사업 요구를 균형 있게 고려해야 합니다.

\[93\] \[94\] \[95\] \[96\]

------------------------------------------------------------------------

## 슬라이드 49

용어 정리

· HSM: 암호화 키를 안전하게 보관·사용하는 하드웨어 장치 · SGX/TEE: CPU
내부의 신뢰 실행 환경으로, 코드와 데이터를 암호화된 영역에서 실행 · MPC:
개인 키를 여러 파티의 조각으로 나누어 공동 계산하는 방식 · 멀티시그:
블록체인 네이티브 기능으로 여러 서명이 필요한 지갑

\[97\] \[98\] \[99\]

------------------------------------------------------------------------

## 슬라이드 50

질문과 답변

궁금한 점을 언제든 말씀해 주세요.

------------------------------------------------------------------------

## 슬라이드 51

향후 조치 및 학습 경로

· 내부 코드 리뷰와 정책 문서 개선을 시작하십시오. · HSM, SGX, MPC 등을
실험할 수 있는 테스트베드를 구축하십시오. · 조직 전체의 역할 분리 및 키
분배 계획을 점검하십시오. · 멱등성과 리오그 등 신뢰성 주제는 별도
세션에서 다룰 예정입니다.

------------------------------------------------------------------------

## 슬라이드 52

감사합니다

발표 자료와 추가 질문은 언제든 연락해 주세요.

------------------------------------------------------------------------

## 슬라이드 53

참고 자료

\[1\] 53665293254061†L303-L311 \[2\] 594874494506770†L354-L363 \[3\]
339610918424151†L18-L24 \[4\] 983136223595575†L367-L374 \[5\]
270620459078700†L708-L739 \[6\] 812401615236055†L136-L158 \[7\]
139793314602716†L97-L126 \[8\] 441634903650143†L305-L323 \[9\]
441634903650143†L399-L403 \[10\] 441634903650143†L518-L537 \[11\]
816226903195394†L292-L297 \[12\] 816226903195394†L426-L430 \[13\]
216576818716638†L260-L273 \[14\] 250595468657829†L240-L246 \[15\]
816226903195394†L426-L437
